# Модуль осуществляет все фукнкции работы с БД

def create_dict(id:int, surname:str, name:str, fathername:str, telefon:int, comment:str):
    ''' 
    функция-консруктор - для создания словаря по аргументам, в соответсвие с столбцами таблицы БД
    
    Вход:
        корректный набор данных строк и целых чисел, при этом отсутсвующие не допускаются
        вызывающий должен направить хотя бы пустое значение
    Возвращает:
        успешное выполнение - словарь, заполненнымй значениями (аргументами) со входа
        сбой в заполении - (-1), как индикатор сбоя операции заполнения словаря аргументами
    '''
    try:  # на случай, если не передали какой-то аргумент для заполнения словаря значениямм
        mydict = {
            'id': id,
            'surname': surname,
            'name': name,
            'fathername': fathername,
            'telefon': telefon,
            'comment': comment
        }
    except:
        return -1     # сбой выполнения
    return mydict     # штатное выполнение

def create_dict_empty():
    ''' 
    функция-консруктор - для создания пустого словаря, в соответсвие с столбцами таблицы БД
    Вход:
       отсутсвует
    Возвращает:
        пустой словарь для дальнейшего его заполненнения
    '''
    mydict = {
        'id': 0,
        'surname': "",
        'name': "",
        'fathername': "",
        'telefon': 800000000000,
        'comment': ""
    }
    return mydict

def m_adding(name_path_file : str, record : list) -> int:
    '''
    функия для добавления записи(-ей) в конец БД (файла .json)
    
    Аргументы:
        name_path_file  - тип данных "str | строка"
                        в данной реализации имя файла БД с расширением .json
                        без указания пути к файлу (корневой каталог с файлом main.py)
        record - тип данных "list | список"
                список из словарей: 1 запись|строка в БД или несколько записей|строк в БД
                                    [dict(i)], где i от 1 до len+1
    Значение:
        штатное выполнение - возвращает БД в виде списка словарей (для выводав консоль)
        сбой при выполнении - (-1) для отправки сообщения из контроллера в ui
    Пояснение:
        1. Поверка передали 1 запись в БД или несколько записей в БД (сколько словарей в списке)
        2. Преобразование в .json
        3. Окрытие файла для добавления и запись в конец
    '''
    try:
        import json                                 # импортируем библиотеку
        with open(name_path_file, "a+", encoding='utf-8') as my_file:  # Записываем в файл
            for i in range(0, len(record)):
                string_json = json.dumps(record[i]) # сериализуем его в JSON-структуру, как строку
                # print(string_json)
                my_file.write(f'{string_json}\r')   # Записываем в файл с возвратом корретки
        return 1
    except:
        return -1

def m_delete(name_path_file : str, id_value : int) -> int:
    '''
    функия удаления записи указанной позиции в БД (файла .json)
    Аргументы:
        name_path_file  - тип данных "str | строка"
                        в данной реализации имя файла БД с расширением .json
                        без указания пути к файлу (корневой каталог с файлом main.py)
        id_value - тип данных список из "int"
                    номер или id-записи для удаления из БД

    Значение:
        1 - штатное выполнение
        -1 - сбой при выполнении, для отправки сообщения из контроллера в ui
    Пояснение:
        1. Окрытие файла на чтение .json
        2. Сохранение в типе данных json
        3. Закрытие файла .json
        4. Удаление строки с нужным номером id
        5. Открытие файла перезапись .json
        6. Перезапись файла в типе данных json
        3. Закрытие файла
    '''
    # try:
    #     import json                                 # импортируем библиотеку
    #     with open(name_path_file, "r", encoding='utf-8') as my_file:  # Записываем в файл
    #         string_json = my_file.readlines()
    # #     string_json 

    #     for i in range(0, len(record)):
    #         string_json = json.dumps(record[i]) # сериализуем его в JSON-структуру, как строку
    #         # print(string_json)
    #         my_file.write(f'{string_json}\r')  # Записываем в файл с возвратом корретки
    #     return 1
    # except:
    #     return -1

def m_edit(name_path_file : str, id_value : int) -> int:
    '''
    функия редактирования записи указанной позиции в БД (файла .json)
    Аргументы:
        name_path_file  - тип данных "str | строка"
                        в данной реализации имя файла БД с расширением .json
                        без указания пути к файлу (корневой каталог с файлом main.py)
        id_value - тип данных список из "int"
                    fномер или id-записи для редактирования из БД

    Значение:
        1 - штатное выполнение
        -1 - сбой при выполнении, для отправки сообщения из контроллера в ui
    Пояснение:
        1. Окрытие файла на чтение .json
        2. Сохранение в типе данных json
        3. Закрытие файла .json
        4. Замена строки с нужным номером id
        5. Открытие файла перезапись .json
        6. Перезапись файла в типе данных json
        3. Закрытие файла
    '''
    pass

def m_search(name_path_file : str, input_str : str) -> list:
    '''
    функия поиска записи по указанному значению в БД (файла .json)
    Аргументы:
        name_path_file  - тип данных "str | строка"
                        в данной реализации имя файла БД с расширением .json
                        без указания пути к файлу (корневой каталог с файлом main.py)
        input_str - строка (но думаю должен быть правильно сформированный словарь или список)
                    значение для поиска
    Значение:
        result - штатное выполнение возвращается список из словарей
        -1 - сбой при выполнении, возвращается список из [-1]
    Пояснение:
        1. Окрытие файла на чтение .json
        2. Сохранение в типе данных json
        3. Закрытие файла .json
        4. Поиск строк по нужному критерию
        5. Формирование нового словаря из результата поиска
    '''
    pass

# def convert_str_to_dict(t_str : str) -> dict:
#     pass


# передача небольшой функции в качестве аргумента:
# pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
# pairs.sort(key=lambda pair: pair[1])
# pairs
# -> [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]



# Небольшие анонимные функции могут быть созданы с помощью lambda. 
# Эта функция возвращает сумму двух своих аргументов: lambda a, b: a+b. 
# Лямбда-функции можно использовать везде, где требуются функциональные объекты.
# Они синтаксически ограничены одним выражением. 
# Семантически они являются просто синтаксическим сахаром для обычного определения функции. 
# Как и определения вложенных функций, 
# лямбда-функции могут ссылаться на переменные из содержащей области:
# def make_incrementor(n):
#     return lambda x: x  + n
# f = make_incrementor(42)
# f(0)   ->   42
# f(1)   ->   43